---
layout: post
title: "JS Warmup - Observables"
date: 2020-10-24 15:00:00 +0200
categories: [javascript]
---

# JS Warmup

![Ã§a va bien se passer](https://media.giphy.com/media/jqeTaaiD3rLKE/giphy.gif)

_Ã‡a va bien se passer_

## Exercice 1 - On commence doucement

Codez une fonction `sum` prenant un nombre indÃ©fini de paramÃ¨tres et retournant la somme des nombres.

Correction :

```js
// utilisation des rest paramters
function sum(...number) {
  // les rest parameters s'utilisent comme des tableaux
  // on peut donc utiliser la mÃ©thode "reduce" du prototype Array
  // pour faire la somme
  return numbers.reduce((acc, curr) => acc + curr, 0);
}
```

**Note : pour la mÃ©thode `reduce`**
```js
const tableau = [4, 5, 6];
const reducerCallback = (accumulateur, valeurCourante) => { return accumulateur + valeurCourante }

tableau.reduce(reducerCallback, 0); // ici, je spÃ©cifie la valeur de dÃ©part
```
- 1er tour de boucle : `accumulateur` vaut 0 (valeur de dÃ©part) et `valeurCourante` vaut 4 (premiÃ¨re case du tableau) et `reducerCallback` retourne 4
- 2Ã¨me tour de boucle : `accumulateur` vaut 0 + 4 = 4 et `valeurCourante` vaut 5 (deuxiÃ¨me case du tableau) et `reducerCallback` retourne 9
- 3Ã¨me tour de boucle : `accumulateur` vaut 4 + 5 = 9 et `valeurCourante` vaut 6 (troisiÃ¨me case du tableau) et `reducerCallback` retourne 15
- AprÃ¨s le troisiÃ¨me tour, c'est terminÃ©, le tableau est parcouru.
Et le rÃ©sultat final est donc 15

## Exercice 2 - Escalade VÃ©loce ðŸš€

### 2A

Ecrivez une fonction `isFunction` qui prend un paramÃ¨tre et qui vÃ©rifie qu'il s'agisse bien d'une fonction. Aidez vous de l'opÃ©rateur [`typeof`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/L_op%C3%A9rateur_typeof).

`isFunction` devra fonctionner comme suit :

```js
const f1 = () => {};
function f2() {}
const nombre = 12;

isFunction(f1); // retourne true
isFunction(f2); // retourne true
isFunction(nombre); // retourne false
```

Correction : 

```js
function isFunction(f) {
  // un simple "typeof" suffit
  return typeof f === 'function';
}
```

### 2B

Ecrivez une fonction `filterNonFunctions` qui prend en paramÃ¨tre un nombre indÃ©fini d'arguments sous la forme d'un _rest parameter_ et qui retourne un tableau ne contenant **que** les arguments Ã©tant des fonctions.
Pour cela, aidez-vous de la mÃ©thode `filter` du prototype `Array`.

Elle devra fonctionner comme suit :

```js
const f1 = () => {};
function f2() {}
const nombre = 12;

const functions = filterNonFunctions(f1, nombre, f2); // [f1, f2]
```

Correction :

```js
function filterNonFunctions(...functions) {
  // il suffit d'utiliser la mÃ©thode "filter"
  // du prototype Array et la mÃ©thode isFunction prÃ©cÃ©demment Ã©crite
  return functions.filter(isFunction);
}
```

### 2C

Ecrivez dÃ©sormais une fonction `pipe` qui fonctionne comme suit : 

- nombre indÃ©fini de fonctions en entrÃ©e ; 
- filtre les arguments qui ne sont pas des fonctions ; 
- stocke le tableau rÃ©sultant du filtre ; 
- retourne une nouvelle fonction 
- prenant un nombre indÃ©fini d'arguments ; 
- exÃ©cute chaque fonction `n` en lui passant en argument le rÃ©sultat de l'appel `n - 1` ; 
- retourne le rÃ©sultat final.

Exemple :

```js
// On a des fonctions de base
const multiply = (x, y) => x * y;
const square = (x) => x * x;
const double = (y) => y * 2;
const addTen = (z) => z + 10;

// pipe prend un nombre indÃ©fini de fonctions en argument
// Ici, on crÃ©e trois nouvelles fonctions
const piped1 = pipe(multiply, square, double, addTen);
const piped2 = pipe(square, double);
const piped3 = pipe();

// piped1(2, 3) va exÃ©cuter Ã  la suite :
// multiply(2, 3), square(6), double(36), addTen(72)
const result1 = piped1(2, 3);

// piped2(4) va exÃ©cuter Ã  la suite :
// square(4), double(16)
const result2 = piped2(4);

// piped3 ne va rien exÃ©cuter
const result3 = piped3();

console.log(result1); // affiche 86
console.log(result2); // affiche 32
console.log(result3); // undefined
```

Correction : 

```js
function pipe(...functions) {
  // d'abord on filtre les fonctions
  const fns = filterNonFunctions(...functions);
  // on retourne une nouvelle fonction
  return (...args) => {
    // si nous avons au moins une fonction
    if (fns.length > 0) {
      // on va faire un "reduce" un peu particulier
      return fns // reduce uniquement sur le tableau moins son premier Ã©lÃ©ment
              .splice(1)
              // "val" est l'accumulateur, et "f" la valeur courante
              // fns[0](...args) est la valeur initiale
              .reduce((val, f) => f(val), fns[0](...args));    
    }
  }
};
```

## Exercice 3 - Same, but different

Ecrivez une fonction `compose` qui fonctionne comme suit :

```js
const multiply = (x, y) => x * y;
const square = (x) => x * x;
const double = (y) => y * 2;
const addTen = (z) => z + 10;

// compose prend un nombre indÃ©fini de fonctions en argument
// et retourne une nouvelle fonction
const composed1 = compose((x) => multiply(x, 3), square, double, addTen);
const composed2 = compose(square, double);
// la nouvelle fonction prend un nombre indÃ©fini d'arguments
// et exÃ©cute les diffÃ©rentes fonctions comme une composition mathÃ©matique
const result1 = composed1(2);
const result2 = composed2(4);

console.log(result1); // affiche 1728
console.log(result2); // affiche 64
```

_Indice : `compose` est le pendant de `pipe` : au lieu d'exÃ©cuter les fonctions dans l'ordre passÃ©, elle les exÃ©cute dans l'ordre inverse (type `f(g(x))`)_

Correction : 

```js
function compose(...functions) {
  const fns = filterNonFunctions(...functions);
  return (...args) => {
    if (fns.length > 0) {
      // Pareil que pour "pipe", sauf qu'on "reverse" le tableau
      return fns.reverse().splice(1).reduce((val, f) => f(val), fns[fns.length -1](...args));
    }
  }
}
```

## Exercice 4 - Promises et Observables

### 4A

Allez lire la documentation sur [les Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) avant de faire l'exercice.

Ecrivez une fonction `delay` qui fonctionne comme suit :

```js
const multiply = (x, y) => x * y;

// delay prend en paramÃ¨tre une fonction et un timeout (millisecondes)
// et retourne une nouvelle fonction qui :
// - retournera une Promise
// - exÃ©cutera la fonction (ici multiply) aprÃ¨s le timeout
const delayed = delay(multiply, 2000);
delayed(3, 4).then((res) => console.log(res)); // affichera 12 aprÃ¨s 2s
```

Correction :

```js
function delay(fn, timeout) {
  return (...args) => {

    // Cette fonction sera passÃ©e au constructeur de la Promise
    // Elle prend deux paramÃ¨tres, resolve et reject : 
    // https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Promise
    const promiseCallback = (resolve, reject) => {

      const timedOutFunction = () => {
        let res;
        // Le try...catch n'Ã©tait pas demandÃ©
        // Je l'ai rajoutÃ©
        try {
          res = fn(...args);
          resolve(res);
        } catch (exception) {
          reject(exception)
        }
      };

      // On enclenche le setTimeout
      setTimeout(timedOutFunction, timeout);
    };

    return new Promise(promiseCallback);
  }
}
```

### 4B

On a la classe suivante :

```js
class Observable {
  // rest parameters
  constructor(...args) {
    // on ne fait pas "this.values"
    // afin que le champ reste privÃ©
    let values = args;
    // idem avec subscribers, qui sera un tableau de fonctions
    const subscribers = [];
    // la mÃ©thode "next" prend des rest parameters en entrÃ©e
    this.next = (...vals) => {
      // elle met Ã  jours "values"
      values = [...vals];
      // et dÃ©clenche tous les traitements avec ces nouvelles valeurs
      subscribers.forEach((f) => f(...values));
    };
    // "subscribe" enregistre simplement une nouvelle fonction
    // qui sera exÃ©cutÃ©e Ã  la prochaine valeur Ã©mise par "next"
    this.subscribe = (f) => {
      subscribers.push(f);
    };
  }
}
```

En vous aidant de cette classe, Ã©crivez une fonction `debounce` de sorte Ã  ce que le code suivant fonctionne :

```js
const square = (x) => x ** 2;

// "debounce" prend une fonction ainsi qu'un timeout en paramÃ¨tre
// et retourne un Observable
const debounced = debounce(square, 1000);

const subscriber = (res) => console.log("res", res);

// (1) DEVRAIT exÃ©cuter square aprÃ¨s 1s et afficher 9
debounced(3).subscribe(subscriber);
// (2) se dÃ©clenchera aprÃ¨s 1.5s, exÃ©cutera square et affichera 4
setTimeout(() => debounced(2), 1500);
debounced(10); // (3) annulera l'appel (1) et relancera un nouveau timeout
```

Indices :

- vous pouvez vous aider de [cet article](https://dev.to/nugetchar/debounce-and-throttle-47cd), Ã©crit par votre humble intervenant. Par contre l'implÃ©mentation qui s'y trouve n'est pas _totalement_ celle demandÃ©e ici ðŸ™ƒ.


Correction : 

```js
function debounce(fn, timeout) {
  let timer;
  let obs = new Observable();
  return (...args) => {
    clearTimeout(timer);
    // Ã€ la fin du timeout, on n'a plus qu'Ã  donner la nouvelle valeur Ã  l'Observable
    timer = setTimeout(() => obs.next(fn(...args)), timeout)
    // On retourne l'Observable
    return obs;
  }
}
```

### 4C

Reprenez la fonction `delay` et, au lieu de retourner une `Promise`, retournez un `Observable`.

Correction :

```js
function delay(fn, timeout) {
  let obs = new Observable();
  return (...args) => {
    setTimeout(() => obs.next(fn(...args)), timeout);
    return obs;
  }
}
```

### 4D

Dans la classe `Observable`, implÃ©mentez une mÃ©thode `pipe` : contrairement Ã  la premiÃ¨re fonction codÃ©e dans les prÃ©cÃ©dents exercices, celle-ci ne retournera pas une fonction mais exÃ©cutera directement les fonctions passÃ©es en paramÃ¨tre et retournera un `Observable` contenant le rÃ©sultat.

Le code suivant doit fonctionner :

```js
class Observable {
  constructor(...args) {
    let values = args;
    const subscribers = [];
    this.next = (...vals) => {
      values = [...vals];
      subscribers.forEach((f) => f(...values));
    };
    this.subscribe = (f) => {
      subscribers.push(f);
      f(...values);
    };
    this.pipe = (...functions) => {
      // TODO: implÃ©mentez cette mÃ©thode
      // Pensez Ã  filtrer les arguments qui ne sont pas des fonctions
      // Vous devez retourner un Observable comportant le rÃ©sultat final
      // Pour le reste, c'est sensiblement pareil que la prÃ©cÃ©dente
      // fonction pipe()
    };
  }
}

new Observable(4)
  .pipe(
    (x) => x ** 2,
    (x) => ("" + x).split(""),
    (numbers) => numbers.map((x) => +x),
    (numbers) => numbers.reduce((acc, curr) => acc + curr, 0)
  )
  .subscribe((res) => console.log("resultat", res)); // 7
```


Correction :


```js
class Observable {
  constructor(...args) {
    let values = args;

    const subscribers = [];

    this.next = (...vals) => {
      values = [...vals];
      subscribers.forEach((f) => f(...values));
    };

    this.subscribe = (f) => {
      subscribers.push(f);
      f(...values);
    };

    this.pipe = (...functions) => {
      // on filtre les fonctions
      const fns = filterNonFunctions(...functions);
      const obs = new Observable();
      // s'il en reste, alors on les exÃ©cute les unes Ã  la suite des autres
      if (fns.length > 0) {
        const res = fns.splice(1).reduce((val, fn) => fn(val), fns[0](...values));
        obs.next(res);
      }
      // on retourne l'Observable
      return obs;
    };

    const filterNonFunctions = (...fns) => {
      return fns.filter((f) => typeof f === 'function');
    }
  }
}
```
